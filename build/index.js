!function(t){var e={};function i(s){if(e[s])return e[s].exports;var r=e[s]={i:s,l:!1,exports:{}};return t[s].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.m=t,i.c=e,i.d=function(t,e,s){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)i.d(s,r,function(e){return t[e]}.bind(null,r));return s},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=0)}([function(t,e,i){"use strict";i.r(e);var s="uniform mediump mat4 projection;\nuniform mediump mat4 view;\nuniform mediump mat4 model;\n\nattribute vec2 vertexPosition;\n\nvoid main() {\n  gl_Position = projection * view * model * vec4(vertexPosition, 0.0, 1.0);\n}\n",r="uniform mediump vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}\n";function h(t){switch(t){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;case"mat3":return 9;case"mat4":return 16}}function a(t,e){let i;const s=[];for(;null!==(i=e.exec(t));)s.push({name:i[3],components:h(i[2])});return s}class n{constructor(t,e,i){const s=`${e}\n${i}`;this.uniforms=a(s,/uniform\s+(\w+\s+)*(\w+)\s+(\w+)\s*;/g),this.attributes=a(s,/attribute\s+(\w+\s+)*(\w+)\s+(\w+)\s*;/g);const r=t.createShader(t.VERTEX_SHADER);t.shaderSource(r,e),t.compileShader(r);const h=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(h,i),t.compileShader(h),this.program=t.createProgram(),t.attachShader(this.program,r),t.attachShader(this.program,h),t.linkProgram(this.program);for(const e of this.uniforms)this[e.name]=t.getUniformLocation(this.program,e.name);for(const e of this.attributes)this[e.name]=t.getAttribLocation(this.program,e.name);this.vertexSize=this.attributes.reduce((t,e)=>t+e.components,0)}use(t){t.useProgram(this.program);let e=0;for(const i of this.attributes)t.enableVertexAttribArray(this[i.name]),t.vertexAttribPointer(this[i.name],i.components,t.FLOAT,!1,4*this.vertexSize,e),e+=4*i.components}}class o{constructor(){this.UP=1,this.DOWN=2,this.LEFT=4,this.RIGHT=8,this.ACTION=16,this.pressed=0,this.lastPressed=0,this.justPressed=0,this.justReleased=0}press(t){this.pressed|=t}release(t){this.pressed&=~t}isPressed(t){return(this.pressed&t)===t}wasJustPressed(t){return(this.justPressed&t)===t}wasJustReleased(t){return(this.justReleased&t)===t}update(){this.justPressed=this.pressed&~this.lastPressed,this.justReleased=this.lastPressed&~this.pressed,this.lastPressed=this.pressed}}var l="uniform mediump mat4 projection;\nuniform mediump mat4 view;\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexTexCoord;\n\nvarying highp vec2 texCoord;\n\nvoid main() {\n  gl_Position = projection * view * vec4(vertexPosition, 0.0, 1.0);\n  texCoord = vertexTexCoord;\n}\n",c="precision highp float;\n\nconst float tolerance = 0.2;\n\nuniform sampler2D sampler;\nuniform mediump vec4 wallColor;\nuniform mediump vec4 roomColor;\nuniform mediump vec2 quadSize;\n\nvarying highp vec2 texCoord;\n\nvoid main() {\n  vec2 quadStep = 1.0 / quadSize;\n\n  float neighbors = 0.0;\n  neighbors += 1.0 - step(tolerance,\n    texture2D(sampler, vec2(texCoord.x - quadStep.x, texCoord.y)).a);\n  neighbors += 1.0 - step(tolerance,\n    texture2D(sampler, vec2(texCoord.x + quadStep.x, texCoord.y)).a);\n  neighbors += 1.0 - step(tolerance,\n    texture2D(sampler, vec2(texCoord.x, texCoord.y - quadStep.y)).a);\n  neighbors += 1.0 - step(tolerance,\n    texture2D(sampler, vec2(texCoord.x, texCoord.y + quadStep.y)).a);\n\n  float current = step(tolerance,\n    texture2D(sampler, vec2(texCoord.x, texCoord.y)).a);\n\n  float wall = neighbors * current;\n\n  gl_FragColor = wallColor * wall + roomColor * current;\n}\n";const f=16,d=1,m=10;class u{constructor(t,e,i,s){this.x=t,this.y=e,this.w=i,this.h=s,this.snakes=0,this.containsGem=!1,this.containsHeart=!1,this.containsExit=!1}isLeaf(){return!this.childA&&!this.childB}split(){if(!this.isLeaf()||this.w<2*f||this.h<2*f)return this.createRoom(),!1;this.w/this.h<=.75?this.splitHorizontally():this.h/this.w<=.75?this.splitVertically():Math.random()<.5?this.splitHorizontally():this.splitVertically(),this.childA.split(),this.childB.split()}splitHorizontally(){const t=Math.round(f+Math.random()*(this.h-2*f));this.childA=new u(this.x,this.y,this.w,t),this.childB=new u(this.x,this.y+t,this.w,this.h-t)}splitVertically(){const t=Math.round(f+Math.random()*(this.w-2*f));this.childA=new u(this.x,this.y,t,this.h),this.childB=new u(this.x+t,this.y,this.w-t,this.h)}createRoom(){this.roomW=Math.round(m+Math.random()*(this.w-2*d-m)),this.roomH=Math.round(m+Math.random()*(this.h-2*d-m)),this.roomX=Math.round(this.x+d+Math.random()*(this.w-this.roomW-2*d)),this.roomY=Math.round(this.y+d+Math.random()*(this.h-this.roomH-2*d))}leafCount(){return this.isLeaf()?1:this.childA.leafCount()+this.childB.leafCount()}visitLeaves(t){if(this.isLeaf())return t(this);this.childA.visitLeaves(t),this.childB.visitLeaves(t)}visitLeafPairs(t){if(this.isLeaf())return this;const e=this.childA.visitLeafPairs(t),i=this.childB.visitLeafPairs(t);return t(e,i),Math.random()<.5?e:i}getRandomLeaf(){return this.isLeaf()?this:Math.random()<.5?this.childA.getRandomLeaf():this.childB.getRandomLeaf()}}const x=10,g=5;class p{constructor(t,e,i){this.width=e,this.height=i,this.gridWidth=Math.ceil(this.width/x),this.gridHeight=Math.ceil(this.height/x),this.root=new u(0,0,this.gridWidth,this.gridHeight),this.root.split(),this.grid=new Uint8Array(this.gridWidth*this.gridHeight);const s=new Float32Array([0,0,0,0,this.width-1,0,1,0,0,this.height-1,0,1,this.width-1,this.height-1,1,1]),r=new Uint16Array([0,2,1,1,2,3]);this.root.visitLeaves(t=>{for(let e=t.roomY;e<t.roomY+t.roomH;e++)for(let i=t.roomX;i<t.roomX+t.roomW;i++)this.grid[e*this.gridWidth+i]=255}),this.root.visitLeafPairs((t,e)=>{const i=Math.floor(t.roomX+t.roomW/2),s=Math.floor(t.roomY+t.roomH/2),r=Math.floor(e.roomX+e.roomW/2),h=Math.floor(e.roomY+e.roomH/2),a=Math.floor(g/2);for(let t=s;t!==h;t+=Math.sign(h-s))for(let e=-a;e<=a;e++)this.grid[t*this.gridWidth+i+e]=255;for(let t=i;t!==r;t+=Math.sign(r-i))for(let e=-a;e<=a;e++)this.grid[(h+e)*this.gridWidth+t]=255}),this.texture=t.createTexture(),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.texture),t.texImage2D(t.TEXTURE_2D,0,t.ALPHA,this.gridWidth,this.gridHeight,0,t.ALPHA,t.UNSIGNED_BYTE,this.grid),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,s,t.STATIC_DRAW),this.indexBuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,r,t.STATIC_DRAW),this.shader=new n(t,l,c)}draw(t,e,i,s){t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),this.shader.use(t),t.uniformMatrix4fv(this.shader.projection,!1,e),t.uniformMatrix4fv(this.shader.view,!1,i),s?(t.uniform4f(this.shader.wallColor,0,0,1,1),t.uniform4f(this.shader.roomColor,0,0,0,0)):(t.uniform4f(this.shader.wallColor,0,0,0,0),t.uniform4f(this.shader.roomColor,.07,.07,.07,1)),t.uniform1i(this.shader.sampler,0),t.uniform2f(this.shader.quadSize,this.width,this.height),t.bindTexture(t.TEXTURE_2D,this.texture),t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)}tileAt(t,e){const i=Math.floor(e/x)*this.gridWidth+Math.floor(t/x);return this.grid[i]}getWallDistance(t,e,i,s){i=0===i?1e-5:i,s=0===s?1e-5:s;let r=0,h=0,a=0;do{r=Math.floor((t+i*a)/x)*x,h=Math.floor((e+s*a)/x)*x,a+=x/10}while(0!==this.tileAt(r,h)&&a<1e3);let n=0,o=0,l=(h-e)/s;l=(n=t+i*l)>=r&&n<=r+x?l:1e3;let c=(h+x-e)/s;c=(n=t+i*c)>=r&&n<=r+x?c:1e3;let f=(r-t)/i;f=(o=e+s*f)>=h&&o<=h+x?f:1e3;let d=(r+x-t)/i;return d=(o=e+s*d)>=h&&o<=h+x?d:1e3,Math.min(l,c,f,d)}}class v{constructor(t,e,i){const s=new Float32Array(3*e.vertexSize);let r=0;s[r++]=3,s[r++]=6,s[r++]=20,s[r++]=0,s[r++]=6,s[r++]=0,this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,s,t.STATIC_DRAW),this.x=i.x,this.y=i.y,this.enemiesHit=0,this.angle=i.angle+Math.PI/2,this.model=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,this.x,this.y,0,1])}update(t,e){if(this.x=e.player.x,this.y=e.player.y,this.swingTimer>0){this.swingTimer-=t,this.angle=this.swingBaseAngle-(150-this.swingTimer)/150*Math.PI*2;const i=this.x+20*Math.cos(this.angle),s=this.y+20*Math.sin(this.angle),r=this.angle+Math.PI/2;for(let t=0;t<2;t++){const t=Math.cos(r)*Math.random()*.1,h=Math.sin(r)*Math.random()*.1;e.particleSystem.emit(e.gl,i,s,t,h,1,1,0,1)}for(const t of e.snakeCollection.snakes){if(!t.alive||this.enemiesHit>=2)continue;const r=t.x-this.x,h=t.y-this.y,a=Math.sqrt(r*r+h*h),n=t.x-i,o=t.y-s,l=Math.sqrt(n*n+o*o);a<=25&&l<=25&&(this.enemiesHit++,t.alive=!1,e.particleSystem.emitRandom(e.gl,this.x,this.y,.01,.2,1,0,1,50))}}else this.angle=e.player.angle+Math.PI;this.model[0]=Math.cos(this.angle),this.model[1]=Math.sin(this.angle),this.model[4]=-Math.sin(this.angle),this.model[5]=Math.cos(this.angle),this.model[12]=this.x,this.model[13]=this.y}swing(){this.swingTimer>0||(this.swingTimer=150,this.swingBaseAngle=this.angle,this.enemiesHit=0)}draw(t,e){t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),e.use(t),t.uniformMatrix4fv(e.model,!1,this.model),t.uniform4f(e.color,1,1,0,1),t.drawArrays(t.TRIANGLES,0,3)}}class R{constructor(t,e,i){this.x=t,this.y=e,this.model=new Float32Array([i,0,0,0,0,i,0,0,0,0,1,0,t,e,0,1]),this.collected=!1}update(t){if(this.collected)return;const e=t.player.x-this.x,i=t.player.y-this.y;Math.sqrt(e*e+i*i)<=20&&(t.player.collectGem(t,this),this.collected=!0)}draw(t,e,i){this.collected||(t.uniformMatrix4fv(e.model,!1,this.model),i?t.drawElements(t.TRIANGLES,24,t.UNSIGNED_SHORT,0):t.drawElements(t.LINES,30,t.UNSIGNED_SHORT,24*Uint16Array.BYTES_PER_ELEMENT))}}class T{constructor(t,e,i,s,r,h){const a=new Float32Array([-20,-7,-13,-18,-7,-7,0,-18,6,-7,13,-18,19,-7,0,18]),n=new Uint16Array([1,0,2,3,1,2,3,2,4,5,3,4,5,4,6,2,0,7,4,2,7,6,4,7,0,1,1,2,0,2,1,3,2,3,2,4,3,5,3,4,4,5,5,6,4,6,0,7,2,7,4,7,6,7]);this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,a,t.STATIC_DRAW),this.indexBuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW),this.view=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.gems=[];for(let t=0;t<r;t++)this.gems.push(new R(i+50*t,s,h))}draw(t,e,i){if(t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.use(t),t.uniformMatrix4fv(e.view,!1,this.view),t.uniform4f(e.color,1,0,1,1),i){const s=i.gemTimer<=0||i.gemVisible;for(let r=0;r<this.gems.length;r++)this.gems[r].draw(t,e,i.gems>r+1||s&&r===i.gems-1)}else for(const i of this.gems)i.draw(t,e,!1)}}class E{constructor(t,e){this.gemCollection=new T(t,e,640,330,1,12),this.particleTimer=100+1e3*Math.random(),this.actionTimer=2e3}update(t,e){if(this.actionTimer-=t,e.input.wasJustReleased(e.input.ACTION)&&this.actionTimer<0)return e.reset(),void(e.activeScreen=null);this.particleTimer-=t,this.particleTimer<=0&&(this.particleTimer=100+1e3*Math.random(),e.particleSystem.emitRandom(e.gl,1280*Math.random(),720*Math.random(),.01,.2,1,0,1,50))}draw(t,e,i,s,r){i.use(t),t.uniformMatrix4fv(i.projection,!1,s),this.gemCollection.draw(t,i,null),e.fillText("VICTORY!",640,50),e.fillText("THANKS FOR PLAYING!",640,700)}}class A{constructor(t,e,i,s){this.x=e,this.y=i,this.heartCollection=t,this.model=new Float32Array([s,0,0,0,0,s,0,0,0,0,1,0,e,i,0,1]),this.collected=!1}update(t){if(this.collected)return;const e=t.player.x-this.x,i=t.player.y-this.y;Math.sqrt(e*e+i*i)<=20&&(t.player.collectHeart(t,this),this.collected=!0)}draw(t,e,i){this.collected||(t.uniformMatrix4fv(e.model,!1,this.model),i?t.drawArrays(t.TRIANGLE_FAN,0,this.heartCollection.HEART_SEGMENTS):t.drawArrays(t.LINE_STRIP,1,this.heartCollection.HEART_SEGMENTS-1))}}const w=101,F=10;class B{constructor(t,e,i,s,r,h){this.HEART_SEGMENTS=w;const a=new Float32Array(w*e.vertexSize);let n=0;a[n++]=0,a[n++]=0;for(let t=0;t<(w-1)/2;t++){const e=t*(4/((w-1)/2-1))-2;a[n++]=e*F,a[n++]=-Math.sqrt(1-(Math.abs(e)-1)*(Math.abs(e)-1))*F}for(let t=0;t<(w-1)/2;t++){const e=t*(4/((w-1)/2-1))-2;a[n++]=-e*F,a[n++]=3*Math.sqrt(1-Math.sqrt(Math.abs(e))/Math.SQRT2)*F}this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,a,t.STATIC_DRAW),this.view=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.hearts=[],this.heartX=i,this.heartY=s,this.scale=h;for(let t=0;t<r;t++)this.hearts.push(new A(this,this.heartX,this.heartY,h)),this.heartX+=50*this.scale}update(t){t.lives>this.hearts.length&&(this.hearts.push(new A(this,this.heartX,this.heartY,1)),this.heartX+=50*this.scale)}draw(t,e,i){if(t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),e.use(t),t.uniformMatrix4fv(e.view,!1,this.view),t.uniform4f(e.color,1,0,0,1),i){const s=i.invincibilityTimer>0&&i.visible,r=i.newHeartTimer<=0||i.newHeartVisible;for(let h=0;h<this.hearts.length;h++)this.hearts[h].draw(t,e,i.lives>h+1||r&&h===i.lives-1||s&&h===i.lives)}else for(const i of this.hearts)i.draw(t,e,!1)}}class _{constructor(t,e){this.heartCollection=new B(t,e,300,330,3,7),this.textTimer=1800,this.showText=!1,this.actionTimer=2e3}update(t,e){if(this.actionTimer-=t,e.input.wasJustReleased(e.input.ACTION)&&this.actionTimer<0)return e.reset(),void(e.activeScreen=null);this.textTimer-=t,this.textTimer<=0&&(this.textTimer=800,this.showText=!this.showText)}draw(t,e,i,s,r){i.use(t),t.uniformMatrix4fv(i.projection,!1,s),this.heartCollection.draw(t,i,null),e.fillText("GAME",640,50),e.fillText("OVER",640,100),this.showText&&e.fillText("PRESS SPACE TO TRY AGAIN",640,700)}}const b=5,y=11,S=.2,C=3;class M{constructor(t,e,i,s){const r=new Float32Array(y*e.vertexSize);let h=0;r[h++]=0,r[h++]=0;for(let t=0;t<y-2;t++){const e=2*Math.PI/(y-2)*t;r[h++]=Math.cos(e)*b,r[h++]=Math.sin(e)*b}r[h++]=r[2],r[h++]=r[3],this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW),this.x=i,this.y=s,this.angle=0,this.model=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,i,s,0,1]),this.lives=C,this.invincibilityTimer=0,this.flashTimer=0,this.visible=!0,this.slidingTimer=0,this.slidingX=0,this.slidingY=0,this.sword=new v(t,e,this),this.gems=0,this.gemTimer=0,this.gemFlashTimer=0,this.gemVisible=!0,this.newHeartTimer=0,this.newHeartFlashTimer=0,this.newHeartVisible=!0,this.exitTextVisible=!1}validPosition(t,e,i){return 255===t.tileAt(e-b,i)&&255===t.tileAt(e+b,i)&&255===t.tileAt(e,i-b)&&255===t.tileAt(e,i+b)}update(t,e){const i=t*S;let s=(e.input.isPressed(e.input.LEFT)?-1:0)+(e.input.isPressed(e.input.RIGHT)?1:0),r=(e.input.isPressed(e.input.UP)?-1:0)+(e.input.isPressed(e.input.DOWN)?1:0);this.sword.swingTimer>0&&(s=r=0),0!==s&&0!==r&&(s*=Math.SQRT2/2,r*=Math.SQRT2/2),(e.input.isPressed(e.input.LEFT)||e.input.isPressed(e.input.RIGHT)||e.input.isPressed(e.input.UP)||e.input.isPressed(e.input.DOWN))&&(this.angle=Math.atan2(r,s)),this.slidingTimer>0&&(this.slidingTimer-=t,s=this.slidingX,r=this.slidingY);const h=this.x+s*i,a=this.y+r*i;h!==this.x&&this.validPosition(e.map,h,this.y)&&(this.x=h,this.model[12]=this.x),a!==this.y&&this.validPosition(e.map,this.x,a)&&(this.y=a,this.model[13]=this.y),this.invincibilityTimer>0?(this.invincibilityTimer-=t,this.flashTimer>0?this.flashTimer-=t:(this.flashTimer=85,this.visible=!this.visible)):this.visible=!0,this.gemTimer>0&&(this.gemTimer-=t,this.gemFlashTimer>0?this.gemFlashTimer-=t:(this.gemFlashTimer=80,this.gemVisible=!this.gemVisible)),this.newHeartTimer>0&&(this.newHeartTimer-=t,this.newHeartFlashTimer>0?this.newHeartFlashTimer-=t:(this.newHeartFlashTimer=80,this.newHeartVisible=!this.newHeartVisible)),this.exitTextVisible=!1,e.input.wasJustPressed(e.input.ACTION)&&this.sword.swing(),this.sword.update(t,e)}damage(t,e,i){this.invincibilityTimer>0||(this.lives--,this.invincibilityTimer=1e3,this.slidingTimer=500,this.slidingX=e,this.slidingY=i,t.shake(500),t.particleSystem.emitRandom(t.gl,this.x,this.y,.01,.2,1,0,0,50),0===this.lives&&(t.activeScreen=new _(t.gl,t.basicShader)))}collectGem(t,e){this.gems++,this.gemTimer=800,this.gemFlashTimer=80,t.particleSystem.emitRandom(t.gl,e.x,e.y,.07,.1,1,0,1,50)}collectHeart(t,e){this.lives++,this.newHeartTimer=800,this.newHeartFlashTimer=80,t.particleSystem.emitRandom(t.gl,e.x,e.y,.07,.1,1,0,0,50)}touchExit(t){this.gems<5?this.exitTextVisible=!0:t.activeScreen=new E(t.gl,t.basicShader)}draw(t,e,i){this.exitTextVisible&&e.fillText("COLLECT THE GEMS FIRST",640,360),this.visible&&(this.sword.draw(t,i),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),i.use(t),t.uniformMatrix4fv(i.model,!1,this.model),t.uniform4f(i.color,1,0,0,1),t.drawArrays(t.TRIANGLE_FAN,0,y))}}var U="uniform mediump mat4 projection;\nuniform mediump mat4 view;\nuniform mediump mat4 model;\nuniform mediump vec3 color;\n\nattribute vec2 vertexPosition;\nattribute float vertexAlpha;\n\nvarying mediump vec4 vertexColor;\n\nvoid main() {\n  gl_Position = projection * view * model * vec4(vertexPosition, 0.0, 1.0);\n  vertexColor = vec4(color, vertexAlpha);\n}\n",P="varying mediump vec4 vertexColor;\n\nvoid main() {\n  gl_FragColor = vertexColor;\n}\n";const D=256,I=196;class N{constructor(t){this.shader=new n(t,U,P),this.baseVertices=new Float32Array(D*this.shader.vertexSize),this.baseVertexBuffer=t.createBuffer(),this.magnifiedVertices=new Float32Array(D*this.shader.vertexSize),this.magnifiedVertexBuffer=t.createBuffer(),this.x=0,this.y=0,this.model=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,this.x,this.y,0,1])}update(t,e){if(e.player.x===this.x&&e.player.y===this.y)return;this.x=e.player.x,this.y=e.player.y,this.model[12]=this.x,this.model[13]=this.y;let i=2;this.baseVertices[i]=this.magnifiedVertices[i]=1,i++;for(let t=0;t<D-1;t++){const s=2*Math.PI/(D-2)*t,r=Math.cos(s),h=Math.sin(s),a=Math.min(e.map.getWallDistance(this.x,this.y,r,h),I);this.baseVertices[i]=r*a,this.magnifiedVertices[i]=r*(a+5),i++,this.baseVertices[i]=h*a,this.magnifiedVertices[i]=h*(a+5),i++,this.baseVertices[i]=this.magnifiedVertices[i]=(I-a)/I,i++}const s=e.gl;s.bindBuffer(s.ARRAY_BUFFER,this.baseVertexBuffer),s.bufferData(s.ARRAY_BUFFER,this.baseVertices,s.STATIC_DRAW),s.bindBuffer(s.ARRAY_BUFFER,this.magnifiedVertexBuffer),s.bufferData(s.ARRAY_BUFFER,this.magnifiedVertices,s.STATIC_DRAW)}draw(t,e,i,s){t.bindBuffer(t.ARRAY_BUFFER,s?this.magnifiedVertexBuffer:this.baseVertexBuffer),this.shader.use(t),t.uniformMatrix4fv(this.shader.projection,!1,e),t.uniformMatrix4fv(this.shader.view,!1,i),t.uniformMatrix4fv(this.shader.model,!1,this.model),t.uniform3f(this.shader.color,.7,.7,.7),t.drawArrays(t.TRIANGLE_FAN,0,D)}}const Y=.02;class L{constructor(t,e,i){this.snakeCollection=t,this.x=e,this.y=i,this.angle=2*Math.random()*Math.PI,this.angleChange=.001*Math.random()-5e-4,this.model=new Float32Array([Math.cos(this.angle),Math.sin(this.angle),0,0,-Math.sin(this.angle),Math.cos(this.angle),0,0,0,0,1,0,e,i,0,1]),this.alive=!0,this.charging=!1,this.chargingTimer=500}update(t,e){if(!this.alive)return;let i=Y;const s=e.player.x-this.x,r=e.player.y-this.y,h=Math.sqrt(s*s+r*r),a=s/h,n=r/h;h<7&&e.player.damage(e,a,n),h>10&&h<150&&e.map.getWallDistance(this.x,this.y,a,n)>=h?this.chargingTimer-=t:this.chargingTimer=500,this.charging=this.chargingTimer<=0,this.charging?(this.angle=Math.atan2(r,s),i*=6):this.angle+=1e-4*t;const o=this.x+Math.cos(this.angle)*t*i,l=this.y+Math.sin(this.angle)*t*i;255===e.map.tileAt(o,l)?(this.x=o,this.y=l):(this.angle=this.angle-Math.PI,this.angleChange=.001*Math.random()-5e-4,this.x+=Math.cos(this.angle)*this.snakeCollection.SNAKE_WIDTH,this.y+=Math.sin(this.angle)*this.snakeCollection.SNAKE_WIDTH),this.model[0]=Math.cos(this.angle),this.model[1]=Math.sin(this.angle),this.model[4]=-Math.sin(this.angle),this.model[5]=Math.cos(this.angle),this.model[12]=this.x,this.model[13]=this.y}draw(t,e){this.alive&&(t.uniformMatrix4fv(e.model,!1,this.model),this.charging?(t.uniform4f(e.color,1,0,1,1),t.drawArrays(t.LINE_STRIP,this.snakeCollection.SNAKE_SEGMENTS,this.snakeCollection.SNAKE_SEGMENTS)):(t.uniform4f(e.color,0,1,0,1),t.drawArrays(t.LINE_STRIP,0,this.snakeCollection.SNAKE_SEGMENTS)))}}const H=24,O=30,X=10;class W{constructor(t,e){this.SNAKE_SEGMENTS=H,this.SNAKE_WIDTH=O,this.SNAKE_HEIGHT=X,this.vertices=new Float32Array(2*this.SNAKE_SEGMENTS*t.basicShader.vertexSize),this.vertexBuffer=t.gl.createBuffer(),this.snakes=[];for(let i=0;i<e;i++){let e=null;do{e=t.map.root.getRandomLeaf()}while(e===t.startingRoom||e.snakes>6);this.snakes.push(new L(this,10*(e.roomX+1+Math.random()*(e.roomW-2)),10*(e.roomY+1+Math.random()*(e.roomH-2)))),e.snakes++}this.phase=0,this.chargingPhase=0}update(t,e){const i=e.gl;this.phase+=.01*t,this.chargingPhase+=.06*t,this.phase>2*Math.PI&&(this.phase-=2*Math.PI),this.chargingPhase>2*Math.PI&&(this.chargingPhase-=2*Math.PI),this.vertexIndex=0,this.generateVertices(this.phase),this.generateVertices(this.chargingPhase),i.bindBuffer(i.ARRAY_BUFFER,this.vertexBuffer),i.bufferData(i.ARRAY_BUFFER,this.vertices,i.STATIC_DRAW);for(const i of this.snakes)i.update(t,e)}generateVertices(t){for(let e=0;e<H-4;e++){const i=(O-10)/(H-4)*e-O;this.vertices[this.vertexIndex++]=i,this.vertices[this.vertexIndex++]=Math.sin(e+t)*(X/2)}this.vertices[this.vertexIndex++]=-5,this.vertices[this.vertexIndex++]=X/2,this.vertices[this.vertexIndex++]=0,this.vertices[this.vertexIndex++]=0,this.vertices[this.vertexIndex++]=-5,this.vertices[this.vertexIndex++]=-X/2,this.vertices[this.vertexIndex++]=this.vertices[this.vertexIndex-9],this.vertices[this.vertexIndex++]=this.vertices[this.vertexIndex-9]}draw(t){t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.vertexBuffer),t.basicShader.use(t.gl);for(const e of this.snakes)e.x>=t.cameraX-30&&e.x<=t.cameraX+t.canvas.width+30&&e.y>=t.cameraY-30&&e.y<=t.cameraY+t.canvas.height+30&&e.draw(t.gl,t.basicShader)}}class G{constructor(t,e){this.vertexBuffer=t.gemCollection.vertexBuffer,this.indexBuffer=t.gemCollection.indexBuffer,this.gems=[];for(let i=0;i<e;i++){let e=null;do{e=t.map.root.getRandomLeaf()}while(e===t.startingRoom||e.containsGem);this.gems.push(new R(10*(e.roomX+2+Math.random()*(e.roomW-4)),10*(e.roomY+2+Math.random()*(e.roomH-4)),.7)),e.containsGem=!0}}update(t){for(const e of this.gems)e.update(t)}draw(t){t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.vertexBuffer),t.gl.bindBuffer(t.gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.basicShader.use(t.gl),t.gl.uniform4f(t.basicShader.color,1,0,1,1);for(const e of this.gems)e.x>=t.cameraX-30&&e.x<=t.cameraX+t.canvas.width+30&&e.y>=t.cameraY-30&&e.y<=t.cameraY+t.canvas.height+30&&e.draw(t.gl,t.basicShader,!1)}}class j{constructor(t,e){this.vertexBuffer=t.heartCollection.vertexBuffer,this.indexBuffer=t.heartCollection.indexBuffer,this.hearts=[];for(let i=0;i<e;i++){let e=null;do{e=t.map.root.getRandomLeaf()}while(e===t.startingRoom||e.containsHeart);this.hearts.push(new A(t.heartCollection,10*(e.roomX+2+Math.random()*(e.roomW-4)),10*(e.roomY+2+Math.random()*(e.roomH-4)),.7)),e.containsHeart=!0}}update(t){for(const e of this.hearts)e.update(t)}draw(t){t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.vertexBuffer),t.gl.bindBuffer(t.gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.basicShader.use(t.gl),t.gl.uniform4f(t.basicShader.color,1,0,0,1);for(const e of this.hearts)e.x>=t.cameraX-30&&e.x<=t.cameraX+t.canvas.width+30&&e.y>=t.cameraY-30&&e.y<=t.cameraY+t.canvas.height+30&&e.draw(t.gl,t.basicShader,!0)}}class V{constructor(t){const e=new Float32Array([-15,-5,-15,-15,15,-15,15,15,-15,15,-15,5,-20,0,0,0,-5,-5,-5,5]),i=new Uint16Array([0,1,1,2,2,3,3,4,4,5,6,7,7,8,7,9]);this.vertexBuffer=t.gl.createBuffer(),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.vertexBuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,e,t.gl.STATIC_DRAW),this.indexBuffer=t.gl.createBuffer(),t.gl.bindBuffer(t.gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.gl.bufferData(t.gl.ELEMENT_ARRAY_BUFFER,i,t.gl.STATIC_DRAW);let s=null;do{s=t.map.root.getRandomLeaf()}while(s===t.startingRoom||s.containsExit);this.x=10*(s.roomX+2+Math.random()*(s.roomW-4)),this.y=10*(s.roomY+2+Math.random()*(s.roomH-4)),s.containsExit=!0,this.model=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,this.x,this.y,0,1])}update(t){const e=t.player.x-this.x,i=t.player.y-this.y;Math.sqrt(e*e+i*i)<=20&&t.player.touchExit(t)}draw(t,e){t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.use(t),t.uniformMatrix4fv(e.model,!1,this.model),t.uniform4f(e.color,1,1,0,1),t.drawElements(t.LINES,16,t.UNSIGNED_SHORT,0)}}var k="uniform mediump mat4 projection;\nuniform mediump mat4 view;\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexTexCoord;\n\nvarying highp vec2 texCoord;\n\nvoid main() {\n  gl_Position = projection * view * vec4(vertexPosition, 0.0, 1.0);\n  texCoord = vertexTexCoord;\n}\n",z="uniform sampler2D sampler;\n\nvarying highp vec2 texCoord;\n\nvoid main() {\n  gl_FragColor = texture2D(sampler, texCoord);\n}\n";class q{constructor(t,e,i){this.width=e,this.height=i;const s=new Float32Array([0,0,0,0,this.width-1,0,1,0,0,this.height-1,0,1,this.width-1,this.height-1,1,1]),r=new Uint16Array([0,2,1,1,2,3]);this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,s,t.STATIC_DRAW),this.indexBuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,r,t.STATIC_DRAW),this.texture=t.createTexture(),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.texture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,this.width,this.height,0,t.RGBA,t.UNSIGNED_BYTE,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this.framebuffer=t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture,0),t.bindTexture(t.TEXTURE_2D,null),this.projection=new Float32Array([2/(this.width-1),0,0,0,0,2/(this.height-1),0,0,0,0,-1,0,-1,-1,0,1]),this.view=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.shader=new n(t,k,z)}draw(t,e,i){t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),this.shader.use(t),t.uniformMatrix4fv(this.shader.projection,!1,e),t.uniformMatrix4fv(this.shader.view,!1,i),t.uniform1i(this.shader.sampler,0),t.bindTexture(t.TEXTURE_2D,this.texture),t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)}}var K="attribute vec2 vertexPosition;\nattribute vec2 vertexTexCoord;\n\nvarying highp vec2 texCoord;\n\nvoid main() {\n  gl_Position = vec4(vertexPosition, 0.0, 1.0);\n  texCoord = vertexTexCoord;\n}\n",J="precision highp float;\n\nuniform sampler2D sampler;\nuniform vec2 texSize;\n\nvarying highp vec2 texCoord;\n\nvoid main() {\n  vec2 texStep = 1.0 / texSize;\n\n  vec4 color = vec4(0.0);\n  color += texture2D(sampler, vec2(texCoord.x, texCoord.y));\n  color += texture2D(sampler, vec2(texCoord.x - texStep.x, texCoord.y));\n  color += texture2D(sampler, vec2(texCoord.x + texStep.x, texCoord.y));\n  color += texture2D(sampler, vec2(texCoord.x, texCoord.y - texStep.y));\n  color += texture2D(sampler, vec2(texCoord.x, texCoord.y + texStep.y));\n\n  gl_FragColor = color;\n}\n";class Q{constructor(t,e,i){this.width=e,this.height=i;const s=new Float32Array([-1,1,0,1,1,1,1,1,-1,-1,0,0,1,-1,1,0]),r=new Uint16Array([0,2,1,1,2,3]);this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,s,t.STATIC_DRAW),this.indexBuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,r,t.STATIC_DRAW),this.texture=t.createTexture(),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.texture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,this.width,this.height,0,t.RGBA,t.UNSIGNED_BYTE,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this.framebuffer=t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture,0),this.shader=new n(t,K,J),t.bindTexture(t.TEXTURE_2D,null)}draw(t){t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),this.shader.use(t),t.uniform1i(this.shader.sampler,0),t.uniform2f(this.shader.texSize,this.width,this.height),t.bindTexture(t.TEXTURE_2D,this.texture),t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)}}var $="uniform mediump mat4 projection;\nuniform mediump mat4 view;\nuniform mediump float elapsedTime;\n\nattribute vec2 particlePosition;\nattribute vec2 particleVelocity;\nattribute float particleEmitted;\nattribute vec3 particleColor;\n\nvarying mediump vec4 color;\n\nvoid main() {\n  vec2 position = particlePosition + particleVelocity *\n    (elapsedTime - particleEmitted);\n  gl_Position = projection * view * vec4(position, 0.0, 1.0);\n  color = vec4(particleColor, (1000.0 - (elapsedTime - particleEmitted)) /\n    1000.0);\n  gl_PointSize = 3.0;\n}\n",Z="varying mediump vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}\n";const tt=512;class et{constructor(t){this.shader=new n(t,$,Z),this.particles=new Float32Array(tt*this.shader.vertexSize),this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,this.particles,t.STATIC_DRAW),this.nextParticle=0,this.particleCount=0,this.elapsedTime=0}update(t){this.elapsedTime+=t}emit(t,e,i,s,r,h,a,n,o){for(let t=0;t<o;t++){this.nextParticle=(this.nextParticle+1)%tt,this.particleCount++,this.particleCount>tt&&(this.particleCount=tt);let t=this.nextParticle*this.shader.vertexSize;this.particles[t++]=e,this.particles[t++]=i,this.particles[t++]=s,this.particles[t++]=r,this.particles[t++]=this.elapsedTime,this.particles[t++]=h,this.particles[t++]=a,this.particles[t++]=n}t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,this.particles,t.STATIC_DRAW)}emitRandom(t,e,i,s,r,h,a,n,o){for(let t=0;t<o;t++){this.nextParticle=(this.nextParticle+1)%tt,this.particleCount++,this.particleCount>tt&&(this.particleCount=tt);let t=this.nextParticle*this.shader.vertexSize;const o=Math.random()*Math.PI*2,l=s+Math.random()*(r-s);this.particles[t++]=e,this.particles[t++]=i,this.particles[t++]=Math.cos(o)*l,this.particles[t++]=Math.sin(o)*l,this.particles[t++]=this.elapsedTime,this.particles[t++]=h,this.particles[t++]=a,this.particles[t++]=n}t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,this.particles,t.STATIC_DRAW)}draw(t,e,i){this.particleCount<=0||(t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),this.shader.use(t),t.uniformMatrix4fv(this.shader.projection,!1,e),t.uniformMatrix4fv(this.shader.view,!1,i),t.uniform1f(this.shader.elapsedTime,this.elapsedTime),t.drawArrays(t.POINTS,0,this.particleCount))}}var it="uniform mediump mat4 projection;\nuniform mediump mat4 view;\nuniform mediump mat4 model;\n\nattribute vec2 vertexPosition;\nattribute vec4 vertexColor;\n\nvarying mediump vec4 color;\n\nvoid main() {\n  gl_Position = projection * view * model * vec4(vertexPosition, 0.0, 1.0);\n  color = vertexColor;\n}\n",st="uniform mediump float maxAlpha;\n\nvarying mediump vec4 color;\n\nvoid main() {\n  gl_FragColor = vec4(color.rgb, 1.0) * (1.0 - step(maxAlpha, color.a));\n}\n";class rt{constructor(t,e,i){this.shader=new n(t,it,st),this.vertices=new Float32Array([0,300,0,0,1,0,0,0,0,0,1,.0825,150,300,0,0,1,.165,150,0,0,0,1,.25,390,0,1,0,1,.25,210,0,1,0,1,.3125,210,300,1,0,1,.375,390,300,1,0,1,.4375,210,150,1,0,1,.4375,390,150,1,0,1,.5,450,0,1,1,0,.5,450,300,1,1,0,.5625,600,300,1,1,0,.625,600,0,1,1,0,.6875,450,0,1,1,0,.75,660,300,1,0,0,.75,660,0,1,0,0,.8325,810,300,1,0,0,.915,810,0,1,0,0,1]),this.indices=new Uint16Array([0,1,1,2,2,3,4,5,5,6,6,7,8,9,10,11,11,12,12,13,13,14,15,16,16,17,17,18]),this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,this.vertices,t.STATIC_DRAW),this.indexBuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,this.indices,t.STATIC_DRAW),this.x=e,this.y=i,this.model=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,this.x,this.y,0,1]),this.view=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.elapsedTime=0,this.maxAlpha=1}update(t,e){this.elapsedTime+=t,this.maxAlpha=this.elapsedTime/4e3;for(let t=0;t<this.indices.length;t+=2){const i=this.indices[t],s=this.indices[t+1],r=this.vertices[i*this.shader.vertexSize+5],h=this.vertices[s*this.shader.vertexSize+5];if(h>this.maxAlpha){let t=i*this.shader.vertexSize,a=s*this.shader.vertexSize;const n=this.vertices[t++],o=this.vertices[t++],l=this.vertices[t++],c=this.vertices[t++],f=this.vertices[t++],d=this.vertices[a++],m=this.vertices[a++],u=(this.maxAlpha-r)/(h-r),x=n+(d-n)*u,g=o+(m-o)*u;e.particleSystem.emitRandom(e.gl,this.x+x,this.y+g,.1,.2,l,c,f,50);break}}}draw(t,e,i){t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),this.shader.use(t),t.uniformMatrix4fv(this.shader.projection,!1,e),t.uniformMatrix4fv(this.shader.view,!1,this.view),t.uniformMatrix4fv(this.shader.model,!1,this.model),t.uniform1f(this.shader.maxAlpha,this.maxAlpha),t.drawElements(t.LINES,this.indices.length,t.UNSIGNED_SHORT,0)}}class ht{constructor(t,e,i){const s=new Float32Array([0,0,0,200,70,100,70,200,100,0,100,200,170,200,170,0,200,0,200,200,270,0,270,200,300,0,370,0,300,200,370,200,370,100,330,100,400,0,470,0,400,200,470,200,400,100,470,100,500,0,570,0,500,200,570,200,600,0,600,200,670,0,670,200]);this.indices=new Uint16Array([0,1,0,2,2,3,3,1,4,5,5,6,6,7,8,9,8,11,10,11,12,13,12,14,14,15,15,16,16,17,18,19,18,20,20,21,22,23,24,25,24,26,25,27,26,27,28,29,28,31,30,31]),this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,s,t.STATIC_DRAW),this.indexBuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,this.indices,t.STATIC_DRAW),this.x=e,this.y=i,this.model=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,this.x,this.y,0,1]),this.view=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.elapsedTime=0,this.alpha=0}update(t){this.elapsedTime+=t,this.alpha=this.elapsedTime/4e3}draw(t,e,i,s){t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.use(t),t.uniformMatrix4fv(e.projection,!1,i),t.uniformMatrix4fv(e.view,!1,this.view),t.uniformMatrix4fv(e.model,!1,this.model),t.uniform4f(e.color,1,1,1,this.alpha),t.drawElements(t.LINES,this.indices.length,t.UNSIGNED_SHORT,0)}}class at{constructor(t){this.neonTitle=new rt(t,235,20),this.dungeonTitle=new ht(t,305,400),this.textTimer=4800,this.showText=!1}update(t,e){e.input.wasJustReleased(e.input.ACTION)?e.activeScreen=null:(this.neonTitle.update(t,e),this.dungeonTitle.update(t),this.textTimer-=t,this.textTimer<=0&&(this.textTimer=800,this.showText=!this.showText))}draw(t,e,i,s,r){this.neonTitle.draw(t,s,r),this.dungeonTitle.draw(t,i,s,r),this.showText&&e.fillText("PRESS SPACE TO BEGIN",640,700)}}const nt=1280,ot=720,lt=150,ct=5,ft=3;const dt=new class{constructor(){this.canvasContainer=document.createElement("div"),this.canvasContainer.id="canvas-container",document.body.appendChild(this.canvasContainer),this.canvas=document.createElement("canvas"),this.canvas.width=nt,this.canvas.height=ot,this.canvasContainer.appendChild(this.canvas),this.gl=this.canvas.getContext("webgl"),this.textCanvas=document.createElement("canvas"),this.textCanvas.width=nt,this.textCanvas.height=ot,this.textCanvas.id="textCanvas",this.canvasContainer.appendChild(this.textCanvas),this.textContext=this.textCanvas.getContext("2d"),this.textContext.font="48px Verdana, Arial, Helvetica, sans-serif",this.textContext.textAlign="center",this.textContext.fillStyle="white",this.gl.clearColor(0,0,0,1),this.gl.enable(this.gl.BLEND),this.projection=new Float32Array([2/(this.canvas.width-1),0,0,0,0,-2/(this.canvas.height-1),0,0,0,0,-1,0,-1,1,0,1]),this.cameraX=0,this.cameraY=0,this.view=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,-this.cameraX,-this.cameraY,0,1]),this.input=new o,this.basicShader=new n(this.gl,s,r),this.reset(),this.postProcessor=new Q(this.gl,this.canvas.width,this.canvas.height),this.guiPostProcessor=new Q(this.gl,this.canvas.width,this.canvas.height),this.particleSystem=new et(this.gl),this.activeScreen=new at(this.gl,this.basicShader),this.lastTimestamp=performance.now(),this.frames=0,this.frameTimer=0}reset(){this.map=new p(this.gl,3*this.canvas.width,3*this.canvas.height),this.startingRoom=this.map.root.getRandomLeaf(),this.player=new M(this.gl,this.basicShader,10*(this.startingRoom.roomX+this.startingRoom.roomW/2),10*(this.startingRoom.roomY+this.startingRoom.roomH/2)),this.heartCollection=new B(this.gl,this.basicShader,30,20,this.player.lives,1),this.gemCollection=new T(this.gl,this.basicShader,30,80,ct,1),this.snakeCollection=new W(this,lt),this.collectibleGemCollection=new G(this,ct),this.collectibleHeartCollection=new j(this,ft),this.exit=new V(this),this.lightCone=new N(this.gl),this.fogOfWar=new q(this.gl,this.map.width,this.map.height),this.shakeTimer=0,this.explanationTimer=2e3}update(t){let e=t-this.lastTimestamp;e<0&&(e=0),this.input.update(),this.activeScreen&&this.activeScreen.update(e,this),this.activeScreen?(this.cameraX=0,this.cameraY=0,this.particleSystem.update(e)):(this.player.update(e,this),this.lightCone.update(e,this),this.snakeCollection.update(e,this),this.collectibleGemCollection.update(this),this.collectibleHeartCollection.update(this),this.heartCollection.update(this.player),this.exit.update(this),this.particleSystem.update(e),this.cameraX=this.player.x-this.canvas.width/2,this.cameraY=this.player.y-this.canvas.height/2,this.explanationTimer>0&&(this.explanationTimer-=e)),this.shakeTimer>0&&(this.shakeTimer-=e,this.cameraX+=8*Math.random()-4,this.cameraY+=8*Math.random()-4),this.view[12]=-this.cameraX,this.view[13]=-this.cameraY,this.lastTimestamp=t,this.frames++,this.frameTimer+=e,this.frameTimer>1e3&&(console.log(`FPS: ${this.frames}`),this.frames=0,this.frameTimer-=1e3)}shake(t){this.shakeTimer=t}draw(){this.textContext.clearRect(0,0,nt,ot),this.activeScreen?(this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.postProcessor.framebuffer),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT)):(this.gl.blendFunc(this.gl.ONE,this.gl.ONE),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.fogOfWar.framebuffer),this.gl.viewport(0,0,this.fogOfWar.width,this.fogOfWar.height),this.lightCone.draw(this.gl,this.fogOfWar.projection,this.fogOfWar.view,!0),this.gl.blendFunc(this.gl.ONE,this.gl.ZERO),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.postProcessor.framebuffer),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.map.draw(this.gl,this.projection,this.view,!0),this.basicShader.use(this.gl),this.gl.uniformMatrix4fv(this.basicShader.projection,!1,this.projection),this.gl.uniformMatrix4fv(this.basicShader.view,!1,this.view),this.snakeCollection.draw(this),this.collectibleGemCollection.draw(this),this.collectibleHeartCollection.draw(this),this.exit.draw(this.gl,this.basicShader),this.player.draw(this.gl,this.textContext,this.basicShader)),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.particleSystem.draw(this.gl,this.projection,this.view),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.guiPostProcessor.framebuffer),this.gl.clearColor(0,0,0,0),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.activeScreen?this.activeScreen.draw(this.gl,this.textContext,this.basicShader,this.projection,this.view):(this.heartCollection.draw(this.gl,this.basicShader,this.player),this.gemCollection.draw(this.gl,this.basicShader,this.player)),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null),this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.activeScreen?this.postProcessor.draw(this.gl):(this.map.draw(this.gl,this.projection,this.view,!1),this.lightCone.draw(this.gl,this.projection,this.view,!1),this.postProcessor.draw(this.gl),this.gl.blendFunc(this.gl.ZERO,this.gl.SRC_ALPHA),this.fogOfWar.draw(this.gl,this.projection,this.view)),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.guiPostProcessor.draw(this.gl),this.explanationTimer>0&&!this.activeScreen&&(this.textContext.fillText("COLLECT THE GEMS",nt/2,ot/2),this.textContext.fillText("FIND THE EXIT",nt/2,ot/2+48))}},mt=t=>{requestAnimationFrame(mt),dt.update(t),dt.draw()};addEventListener("keydown",t=>{switch(t.keyCode){case 38:case 87:case 75:dt.input.press(dt.input.UP),t.preventDefault();break;case 40:case 83:case 74:dt.input.press(dt.input.DOWN),t.preventDefault();break;case 37:case 65:case 72:dt.input.press(dt.input.LEFT),t.preventDefault();break;case 39:case 68:case 76:dt.input.press(dt.input.RIGHT),t.preventDefault();break;case 32:case 88:case 70:dt.input.press(dt.input.ACTION),t.preventDefault()}}),addEventListener("keyup",t=>{switch(t.keyCode){case 38:case 87:case 75:dt.input.release(dt.input.UP),t.preventDefault();break;case 40:case 83:case 74:dt.input.release(dt.input.DOWN),t.preventDefault();break;case 37:case 65:case 72:dt.input.release(dt.input.LEFT),t.preventDefault();break;case 39:case 68:case 76:dt.input.release(dt.input.RIGHT),t.preventDefault();break;case 32:case 88:case 70:dt.input.release(dt.input.ACTION),t.preventDefault()}}),requestAnimationFrame(mt)}]);